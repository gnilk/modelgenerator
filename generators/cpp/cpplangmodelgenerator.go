package cpp

import (
	"fmt"
	"log"
	"modelgenerator/common"
	"os"
	"unicode"
)

func (generator *CodeGenerator) GenerateCode(doc common.XMLDoc, options *common.Options) string {
	code := ""
	if options.SplitInFiles == true {
		log.Printf("Split In Files not supported!\n")
		return code
	}

	code += fmt.Sprintf("#pragma once\n")
	code += fmt.Sprintf("//\n")
	code += fmt.Sprintf("// This file has been generated by ModelGenerator - do NOT edit!\n")
	code += fmt.Sprintf("//\n")

	if options.CPPJson {
		code += fmt.Sprintf("#include <Encoding/encoding.h>\n")
		code += fmt.Sprintf("#include <Encoding/marshal.h>\n")
	}

	code += fmt.Sprintf("namespace %s {\n\n", doc.Namespace)

	if options.CPPJson {
		code += generator.generateJSONBaseClass(&doc, options)
	}

	for _, define := range doc.Defines {
		//log.Printf("Generate for define: %s\n", define.Name)
		code += generator.generateHeaderCodeForDefine(&define, &doc, options)
		//		code += generator.generateCode(&define, options)
	}

	code += fmt.Sprintf("}")

	return code
}

func domainJSONBaseName(doc *common.XMLDoc) string {
	return (string(unicode.ToUpper(rune(doc.Namespace[0]))) + doc.Namespace[1:] + "JSONBase")
}

func (generator *CodeGenerator) generateJSONBaseClass(doc *common.XMLDoc, options *common.Options) string {
	code := ""
	code += fmt.Sprintf("class %s : public IMarshal, public IUnmarshal {\n", domainJSONBaseName(doc))
	code += fmt.Sprintf("public:\n")
	code += fmt.Sprintf("    virtual void Marshal(IEncoder &encoder, std::string name = \"\", bool hasNext = false) const {}\n")
	code += fmt.Sprintf("    virtual bool SetField(std::string &name, std::string &value) { return false; }\n")
	code += fmt.Sprintf("    virtual IUnmarshal *GetUnmarshalForField(std::string &name) { return NULL; };\n")
	code += fmt.Sprintf("    virtual bool PushToArray(std::string &name, IUnmarshal *pData) { return false; };\n")
	code += fmt.Sprintf("};\n")
	return code
}

func (generator *CodeGenerator) generateHeaderCodeForDefine(define *common.XMLDefine, doc *common.XMLDoc, options *common.Options) string {
	code := ""

	log.Printf("Generating code for type='%s', named='%s'\n", define.Type, define.Name)
	switch define.Type {
	case "class":
		code += generator.generateClassCodeDefinition(define, doc, options)
		break
	case "enum":
		code += generator.generateEnumCodeDefinition(define, options)
		break
	default:
		fmt.Printf("[CppLangModelGenerator::generateCode] Error, can't generate code for type '%s'\n", define.Type)
		break
	}

	return code

}

func (generator *CodeGenerator) generateClassCodeDefinition(define *common.XMLDefine, doc *common.XMLDoc, options *common.Options) string {
	code := ""
	// Begin class header
	code += fmt.Sprintf("class %s", define.Name)
	if define.Inherits != "" {
		code += fmt.Sprintf(" : public %s", define.Inherits)
	}
	if options.CPPJson {
		if define.Inherits == "" {
			code += " : public "
		} else {
			code += ", "
		}
		code += fmt.Sprintf("%s", domainJSONBaseName(doc))

	}
	code += fmt.Sprintf(" {\n") // end class header

	// serialize fields first, we need to understand what we are dealing with to properly generate the serialization interface
	fields := ""
	fields += fmt.Sprintf("public:\n")
	for _, field := range define.Fields {
		fields += generator.fieldCode(define, options, &field)
		//generator.methodFromField(define, field, field.TypeMapping(options.CurrentDoc.GOTypeMappings), field.IsList)
	}

	if options.CPPJson {
		code += generateModelGenJSONSupport(define, doc, options)
	}

	code += fields
	code += fmt.Sprintf("};\n\n")
	return code
}

func isFieldUserDefined(field *common.XMLDataTypeField, doc *common.XMLDoc) bool {
	for _, define := range doc.Defines {
		if (define.Name == field.Type) && (define.Type == "class") {
			return true
		}
	}
	return false
}

func getFieldUserDefine(field *common.XMLDataTypeField, doc *common.XMLDoc) *common.XMLDefine {
	for _, define := range doc.Defines {
		if (define.Name == field.Type) && (define.Type == "class") {
			return &define
		}
	}
	return nil
}

func generateModelGenJSONSupport(define *common.XMLDefine, doc *common.XMLDoc, options *common.Options) string {
	// Todo: rename 'bHaveList' to 'bNeedUnmarshalField'
	bNeedUnmarshalField := false
	bNeedPushToArray := false
	code := ""

	code += fmt.Sprintf("public:\n")
	code += fmt.Sprintf("    virtual void Marshal(IEncoder &encoder, std::string name = \"\", bool hasNext = false) const {\n")
	code += fmt.Sprintf("        encoder.Begin(name);\n")

	for _, field := range define.Fields {
		fmt.Printf("%+v\n", field)
		if field.IsList {
			code += writeListMarshalling(&field, options)
			bNeedUnmarshalField = true
		} else if isFieldUserDefined(&field, doc) {
			code += writeFieldForUserDefine(&field, options)
			bNeedUnmarshalField = true
		} else {
			code += writeFieldMarshalling(&field, options)
		}
	}
	code += fmt.Sprintf("        encoder.End(hasNext);\n")
	code += fmt.Sprintf("    }\n")

	// Set field function
	code += fmt.Sprintf("    virtual bool SetField(std::string &name, std::string &value) {\n")
	for _, field := range define.Fields {
		if field.IsList == true {
			// Special case, handled differently
			if field.IsPointer == false {
				code += writeListUnmarshal(&field, options)
			} else {
				bNeedPushToArray = true
			}
		} else {
			code += writeFieldUnmarshal(&field, options)
		}

	}
	code += fmt.Sprintf("        return false;\n")
	code += fmt.Sprintf("    }\n")

	// If we have a list we need to decide who handles sub-unmarshalling of list items
	if bNeedUnmarshalField {
		code += fmt.Sprintf("    virtual IUnmarshal *GetUnmarshalForField(std::string &name) {\n")
		for _, field := range define.Fields {
			if isFieldUserDefined(&field, doc) {
				define := getFieldUserDefine(&field, doc)
				if define == nil {
					fmt.Printf("[ERR] Unable to find definition for variable '%s' of type '%s'\n", field.Name, field.Type)
					// Hmm, no need to progress further
					os.Exit(1)
				}
				code += fmt.Sprintf("        if (name == \"%s\") {\n", field.Name)
				if field.IsPointer {
					if field.IsList {
						code += fmt.Sprintf("            return new %s();\n", field.Type)
					} else {
						code += fmt.Sprintf("            %s = new %s();\n", field.Name, field.Type)
						code += fmt.Sprintf("            return (IUnmarshal *)%s;\n", field.Name)

					}
				} else {
					code += fmt.Sprintf("            return &%s;\n", field.Name)
				}
				code += fmt.Sprintf("        }\n")
			} else if field.IsList == true {
				code += fmt.Sprintf("        if (name == \"%s\") {\n", field.Name)
				code += fmt.Sprintf("            return this;\n")
				code += fmt.Sprintf("        }\n")
			}

		}
		code += fmt.Sprintf("        return NULL;\n")
		code += fmt.Sprintf("    }\n")
	}
	// This is used for objects and lists which are pointers
	if bNeedPushToArray {
		code += fmt.Sprintf("    virtual bool PushToArray(std::string &name, IUnmarshal *ptrData) {\n")
		for _, field := range define.Fields {
			if isFieldUserDefined(&field, doc) {
				if field.IsPointer && field.IsList {
					code += fmt.Sprintf("        if (name == \"%s\") {\n", field.Name)
					code += fmt.Sprintf("            this->%s.push_back((%s *)ptrData);\n", field.Name, field.Type)
					code += fmt.Sprintf("            return true;\n")
					code += fmt.Sprintf("        }\n")
				}
			}
		}
		code += fmt.Sprintf("        return false;\n")
		code += fmt.Sprintf("    }\n")
	}

	return code
}

func writeListUnmarshal(field *common.XMLDataTypeField, options *common.Options) string {
	code := ""
	code += fmt.Sprintf("        if (name == \"%s\") {\n", field.Name)
	fromStringStmt := "value"
	mappedType := field.GetTypeMappingLang(options.CurrentDoc.AnyTypeMappings, "cpp")
	if (mappedType != nil) && (mappedType.Decode != "") {
		fromStringStmt = fmt.Sprintf(mappedType.Decode, "value")
	}
	code += fmt.Sprintf("            %s.push_back(%s);\n", field.Name, fromStringStmt)
	code += fmt.Sprintf("            return true;\n")
	code += fmt.Sprintf("        }\n")

	return code
}

func writeFieldUnmarshal(field *common.XMLDataTypeField, options *common.Options) string {
	code := ""
	if field.IsPointer || isFieldUserDefined(field, options.CurrentDoc) {
		return code
		// nothing to do here
	}

	code += fmt.Sprintf("        if (name == \"%s\") {\n", field.Name)
	fromStringStmt := "value"
	mappedType := field.GetTypeMappingLang(options.CurrentDoc.AnyTypeMappings, "cpp")
	if (mappedType != nil) && (mappedType.Decode != "") {
		fromStringStmt = fmt.Sprintf(mappedType.Decode, "value")
	}
	code += fmt.Sprintf("            %s = %s;\n", field.Name, fromStringStmt)
	code += fmt.Sprintf("            return true;\n")
	code += fmt.Sprintf("        }\n")
	return code
}

func writeListMarshalling(field *common.XMLDataTypeField, options *common.Options) string {
	code := ""
	code += fmt.Sprintf("        encoder.BeginArray(\"%s\");\n", field.Name)
	code += fmt.Sprintf("        for(int i=0;i<%s.size();i++) {\n", field.Name)
	code += fmt.Sprintf("             encoder.WriteField(\"\", %s[i]);\n", field.Name)
	code += fmt.Sprintf("        }\n")
	code += fmt.Sprintf("        encoder.EndArray();\n")
	return code
}

func writeFieldForUserDefine(field *common.XMLDataTypeField, options *common.Options) string {
	define := getFieldUserDefine(field, options.CurrentDoc)
	if define != nil {
		code := fmt.Sprintf("        %s.Marshal(encoder, %s);\n", field.Name, field.Name)
		return code
	}
	fmt.Printf("ERR: can't find user definition for: %s\n", field.Name)
	os.Exit(1)

	return ""
}
func writeFieldMarshalling(field *common.XMLDataTypeField, options *common.Options) string {
	toStringStmt := field.Name
	mappedType := field.GetTypeMappingLang(options.CurrentDoc.AnyTypeMappings, "cpp")
	if (mappedType != nil) && (mappedType.Encode != "") {
		toStringStmt = fmt.Sprintf(mappedType.Encode, field.Name)
	}
	code := fmt.Sprintf("        encoder.WriteField(\"%s\", %s);\n", field.Name, toStringStmt)
	return code
}

func (generator *CodeGenerator) fieldCode(define *common.XMLDefine, options *common.Options, field *common.XMLDataTypeField) string {
	code := ""
	//
	// Note: Type prefix for a list is the list_element prefix
	// example:
	// define:
	//		<field type="int" islist="true" ispointer="true" name="IntList" />>
	// generates:
	//		std::vector<int *> IntList;
	//

	typePrefix := ""
	if field.IsPointer {
		typePrefix = typePrefix + "*"
	}
	prefix := define.Prefix
	if options.MemberPrefix != "" {
		if options.MemberPrefix == "!" {
			prefix = ""
		} else {
			prefix = options.MemberPrefix
		}
	}

	if field.IsList {
		code += fmt.Sprintf("    std::vector<%s %s> %s%s;\n", field.TypeMappingLang(options.CurrentDoc.AnyTypeMappings, "cpp"), typePrefix, prefix, field.Name)
	} else {
		code += fmt.Sprintf("    %s %s%s%s;\n", field.TypeMappingLang(options.CurrentDoc.AnyTypeMappings, "cpp"), typePrefix, prefix, field.Name)
	}

	return code
}

func (generator *CodeGenerator) generateEnumCodeDefinition(define *common.XMLDefine, options *common.Options) string {
	code := ""
	code += fmt.Sprintf("typedef enum {\n")
	for _, Int := range define.Ints {
		code += fmt.Sprintf("    %s%s = %d,\n", define.Prefix, Int.Name, Int.Value)
	}
	code += fmt.Sprintf("} %s;\n\n", define.Name)
	return code
}

// func (generator *CodeGenerator) generateCode(options *common.Options, define *common.XMLDefine) string {
// 	return ""
// }
