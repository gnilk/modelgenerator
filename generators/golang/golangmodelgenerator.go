package golang

import (
	"fmt"
	"log"
	common "modelgenerator/common"
	"strings"
)

type CodeGenerator struct {
	Methods []common.AccessMethod
	Imports []common.XMLImport
}

func CreateGoLangGenerator() common.Generator {
	codeGen := CodeGenerator{}
	return (common.Generator)(&codeGen)
}

func (generator *CodeGenerator) GenerateCode(doc common.XMLDoc, options *common.Options) string {

	code := ""

	generator.Imports = doc.Imports
	// Creating To/From - converters for model, add necessary imports
	if options.Converters {
		generator.addImport("bytes")         //append(doc.Imports, "bytes")
		generator.addImport("encoding/json") //append(doc.Imports, "encoding/json")
		generator.addImport("encoding/xml")  //append(doc.Imports, "encoding/xml")
		generator.addImport("fmt")
	}

	if options.SplitInFiles == true {
		log.Printf("Split In Files not supported!\n")
		return code
	} else {
		code += generator.generateHeader(doc, options.Filename)
		// generate code for all defines
		for _, define := range doc.Defines {
			//log.Printf("Generate for define: %s\n", define.Name)
			code += generator.generateCode(options, &define)
			// if string(outputDir[len(outputDir)-1:]) != "/" {
			// 	outputDir += "/"
			// }
			// fileName := outputDir + define.Name + ".go"

			// if options.Verbose > 0 {
			// 	fmt.Printf("Writing code for %s to %s\n", define.Name, fileName)
			// }
			// ioutil.WriteFile(fileName, []byte(code), 0644)
		}
	}
	return code
}

func (generator *CodeGenerator) addImport(pkgName string) {
	generator.Imports = append(generator.Imports, common.XMLImport{
		DisablePersistence: false,
		Package:            pkgName,
	})
	// doc.Imports = append(doc.Imports, XMLImport{
	// 	DisablePersistence: false,
	// 	Package:            pkgName,
	// })
	// return doc.Imports
}

func (generator *CodeGenerator) generateHeader(doc common.XMLDoc, modelSourceName string) string {

	code := ""
	code += fmt.Sprintf("package %s\n", doc.Namespace)
	code += fmt.Sprintf("\n")
	if len(doc.Imports) > 0 {
		code += fmt.Sprintf("import (\n")
		for _, Import := range doc.Imports {
			//log.Printf("Import: %s", Import.Package)
			importstatements := strings.Split(Import.Package, " ")
			if len(importstatements) == 1 {
				code += fmt.Sprintf("  \"%s\"\n", Import.Package)
			} else {
				code += fmt.Sprintf("  %s \"%s\"\n", importstatements[0], importstatements[1])
			}

		}
		code += fmt.Sprintf(")\n")
	}

	code += fmt.Sprintf("//\n")
	code += fmt.Sprintf("// this code is generated by the modelgenerator\n")
	code += fmt.Sprintf("// data model source = %s\n", modelSourceName)
	code += fmt.Sprintf("//\n")
	code += fmt.Sprintf("\n")

	return code
}
func (generator *CodeGenerator) generateCode(options *common.Options, define *common.XMLDefine) string {
	code := ""

	log.Printf("Generating code for type='%s', named='%s'\n", define.Type, define.Name)
	switch define.Type {
	case "class":
		code += generator.generateClassCode(options, define)
		if options.Converters {
			code += generator.generateClassConverters(define)
		}
		break
	case "enum":
		code += generator.generateEnumCode(options, define)
		break
	default:
		fmt.Printf("[GolangModelGenerator::generateCode] Error, can't generate code for type '%s'\n", define.Type)
		break
	}

	return code
}

// generateEnumCode creates Go Code for an ENUM const declaration
func (generator *CodeGenerator) generateEnumCode(options *common.Options, define *common.XMLDefine) string {

	code := ""
	code += fmt.Sprintf("type %s int64\n", define.Name)
	code += fmt.Sprintf("const (\n")
	code += fmt.Sprintf("  _ = iota\n")
	for _, Int := range define.Ints {
		code += fmt.Sprintf("  %s %s = %d\n", Int.Name, define.Name, Int.Value)
	}
	code += fmt.Sprintf(")\n")
	code += fmt.Sprintf("\n")

	code += fmt.Sprintf("var map%sToName = map[%s]string {\n", define.Name, define.Name)
	for _, Int := range define.Ints {
		code += fmt.Sprintf("  %d:\"%s\",\n", Int.Value, Int.Name)
	}
	code += fmt.Sprintf("}\n")
	code += fmt.Sprintf("\n")

	code += fmt.Sprintf("var map%sToValue = map[string]%s {\n", define.Name, define.Name)
	for _, Int := range define.Ints {
		code += fmt.Sprintf("  \"%s\":%d,\n", Int.Name, Int.Value)
	}
	code += fmt.Sprintf("}\n")
	code += fmt.Sprintf("\n")

	// todo generate map here

	code += fmt.Sprintf("func (this *%s) String() string {\n", define.Name)
	code += fmt.Sprintf("  return map%sToName[*this]\n", define.Name)
	code += fmt.Sprintf("}\n")
	code += fmt.Sprintf("\n")

	code += fmt.Sprintf("func (this %s) MarshalJSON() ([]byte, error) {\n", define.Name)
	code += fmt.Sprintf("  return json.Marshal(this.String())\n")
	code += fmt.Sprintf("}\n")
	code += fmt.Sprintf("\n")

	code += fmt.Sprintf("func (this *%s) UnmarshalJSON(data []byte) error {\n", define.Name)
	code += fmt.Sprintf("  var s string\n")
	code += fmt.Sprintf("  if err := json.Unmarshal(data, &s); err != nil {\n")
	code += fmt.Sprintf("    return fmt.Errorf(\"%s should be a string\")\n", define.Name)
	code += fmt.Sprintf("  }\n")
	code += fmt.Sprintf("  v, ok := map%sToValue[s]\n", define.Name)
	code += fmt.Sprintf("  if !ok {\n")
	code += fmt.Sprintf("    return fmt.Errorf(\"invalid %s\")", define.Name)
	code += fmt.Sprintf("  }\n")
	code += fmt.Sprintf("  *this = v\n")
	code += fmt.Sprintf("  return nil\n")
	code += fmt.Sprintf("}")
	code += fmt.Sprintf("\n")

	return code
}

func (generator *CodeGenerator) generateClassCode(options *common.Options, define *common.XMLDefine) string {

	code := ""

	code += fmt.Sprintf("//\n")
	code += fmt.Sprintf("// %s is generated\n", define.Name)
	code += fmt.Sprintf("//\n")

	code += fmt.Sprintf("type %s struct {\n", define.Name)

	if define.Inherits != "" {
		code += fmt.Sprintf("  %s\n\n", define.Inherits)
	}

	code += generator.generateFields(options, define)

	// code += define.generateFieldCode(define.Guids, "uuid.UUID")
	// code += define.generateFieldCode(define.Strings, "string")
	// code += define.generateFieldCode(define.Ints, "int")
	// code += define.generateFieldCode(define.Bools, "bool")
	// // TODO: Fix this!!
	// code += define.generateFieldCode(define.Times, "time.Time")
	// code += define.generateFieldListCode(define.Lists)
	// code += define.generateFieldEnumCode(define.Enums)
	// code += define.generateFieldObjectCode(define.Objects)
	code += fmt.Sprintf("}\n")
	code += fmt.Sprintf("\n")

	for _, method := range generator.Methods {
		ptrAttrib := "*"
		if method.IsPointer != true {
			ptrAttrib = ""
		}

		if method.Getter == true {
			if method.IsList != true {
				code += fmt.Sprintf("func (this *%s) Get%s() %s%s {\n", define.Name, method.Name, ptrAttrib, method.Type)
				code += fmt.Sprintf("  return this.%s\n", method.Name)
				code += fmt.Sprintf("}\n")
				code += fmt.Sprintf("\n")
			} else {
				code += fmt.Sprintf("func (this *%s) Get%sAsRef() []%s%s {\n", define.Name, method.Name, ptrAttrib, method.Type)
				code += fmt.Sprintf("  return this.%s[:len(this.%s)]\n", method.Name, method.Name)
				code += fmt.Sprintf("}\n")
				code += fmt.Sprintf("\n")

				code += fmt.Sprintf("func (this *%s) Get%sAsCopy() []%s%s {\n", define.Name, method.Name, ptrAttrib, method.Type)
				code += fmt.Sprintf("  newSlice := make([]%s, len(this.%s))\n", method.Type, method.Name)
				code += fmt.Sprintf("  copy(newSlice, this.%s)\n", method.Name)
				code += fmt.Sprintf("  return newSlice\n")
				code += fmt.Sprintf("}\n")
				code += fmt.Sprintf("\n")
			}
		}

		if method.Setter == true {
			if method.IsList != true {
				code += fmt.Sprintf("func (this *%s) Set%s(value %s%s) {\n", define.Name, method.Name, ptrAttrib, method.Type)
				code += fmt.Sprintf("  this.%s = value\n", method.Name)
				code += fmt.Sprintf("}\n")
				code += fmt.Sprintf("\n")
			} else {
				code += fmt.Sprintf("func (this *%s) Set%s(value []%s%s) {\n", define.Name, method.Name, ptrAttrib, method.Type)
				code += fmt.Sprintf("  this.%s = make([]%s, len(value))\n", method.Name, method.Type)
				code += fmt.Sprintf("  copy(this.%s, value)\n", method.Name)
				code += fmt.Sprintf("}\n")
				code += fmt.Sprintf("\n")
			}
		}
	}

	return code
}

func (generator *CodeGenerator) generateFields(options *common.Options, define *common.XMLDefine) string {
	code := ""

	for _, field := range define.Fields {
		log.Printf("  Field: %s\n", field.Name)
		code += generator.goFieldCode(options, &field)
		generator.methodFromField(define, field, field.TypeMapping(options.CurrentDoc.GOTypeMappings), field.IsList)
	}

	return code
}

func (generator *CodeGenerator) goFieldCode(options *common.Options, field *common.XMLDataTypeField) string {
	code := ""

	typePrefix := ""
	if field.IsList {
		typePrefix = typePrefix + "[]"
	}
	if field.IsPointer {
		typePrefix = typePrefix + "*"
	}
	code += fmt.Sprintf("  %s %s%s\n", field.Name, typePrefix, field.TypeMapping(options.CurrentDoc.GOTypeMappings))

	return code
}

func (generator *CodeGenerator) methodFromField(define *common.XMLDefine, field common.XMLDataTypeField, typeString string, isList bool) {

	method := common.AccessMethod{
		Getter:    true,
		Setter:    true,
		IsList:    isList,
		Name:      field.Name,
		Type:      typeString,
		IsPointer: field.IsPointer,
		NoPersist: field.SkipPersistance,
		AutoID:    field.DBAutoID,
	}

	generator.Methods = append(generator.Methods, method)
}

//
// Class converters
//
func (generator *CodeGenerator) generateClassConverters(define *common.XMLDefine) string {
	code := ""

	code += generator.generateToJSONCode(define)
	code += fmt.Sprintf("\n")
	code += generator.generateToXMLCode(define)
	code += fmt.Sprintf("\n")

	code += generator.generateFromJSONCode(define)
	code += fmt.Sprintf("\n")
	code += generator.generateFromXMLCode(define)
	code += fmt.Sprintf("\n")
	return code
}

func (generator *CodeGenerator) generateToJSONCode(define *common.XMLDefine) string {
	code := ""
	code += fmt.Sprintf("// ToJSON creates a JSON representation of the data for the type\n")
	code += fmt.Sprintf("func (this *%s) ToJSON() string {\n", define.Name)

	code += fmt.Sprintf("  b, err := json.MarshalIndent(this, \"\", \"    \")\n")
	code += fmt.Sprintf("  if err != nil {\n")
	code += fmt.Sprintf("    return \"\"\n")
	code += fmt.Sprintf("  }\n")
	code += fmt.Sprintf("  return bytes.NewBuffer(b).String()\n")
	code += fmt.Sprintf("}\n")

	// code += fmt.Sprintf("  b := new(bytes.Buffer)\n")
	// code += fmt.Sprintf("  encoder := json.NewEncoder(b)\n")
	// code += fmt.Sprintf("  encoder.SetIndent(\"\", \"    \")\n")
	// code += fmt.Sprintf("  err := encoder.Encode(this)\n")
	// code += fmt.Sprintf("  if err != nil {\n")
	// code += fmt.Sprintf("    return \"\"\n")
	// code += fmt.Sprintf("  }\n")
	// code += fmt.Sprintf("  return b.String()\n")
	return code
}

func (generator *CodeGenerator) generateToXMLCode(define *common.XMLDefine) string {
	code := ""
	code += fmt.Sprintf("// ToXML creates an XML representation of the data for the type\n")
	code += fmt.Sprintf("func (this *%s) ToXML() string {\n", define.Name)

	code += fmt.Sprintf("  b, err := xml.MarshalIndent(this, \"\", \"    \")\n")
	code += fmt.Sprintf("  if err != nil {\n")
	code += fmt.Sprintf("    return \"\"\n")
	code += fmt.Sprintf("  }\n")
	code += fmt.Sprintf("  return bytes.NewBuffer(b).String()\n")
	code += fmt.Sprintf("}\n")

	// code += fmt.Sprintf("  b := new(bytes.Buffer)\n")
	// code += fmt.Sprintf("  encoder := xml.NewEncoder(b)\n")
	// code += fmt.Sprintf("  encoder.Indent(\"\", \"    \")\n")
	// code += fmt.Sprintf("  err := encoder.Encode(this)\n")
	// code += fmt.Sprintf("  if err != nil {\n")
	// code += fmt.Sprintf("    return \"\"\n")
	// code += fmt.Sprintf("  }\n")
	// code += fmt.Sprintf("  return b.String()\n")
	return code
}

func (generator *CodeGenerator) generateFromXMLCode(define *common.XMLDefine) string {
	code := ""

	code += fmt.Sprintf("// %sFromXML converts an XML representation to the type\n", define.Name)
	code += fmt.Sprintf("func %sFromXML(xmldata string) (*%s, error) {\n", define.Name, define.Name)
	code += fmt.Sprintf("  var value %s\n", define.Name)
	code += fmt.Sprintf("  err := xml.Unmarshal([]byte(xmldata), &value)\n")
	code += fmt.Sprintf("  if err != nil {\n")
	code += fmt.Sprintf("	  return nil, err\n")
	code += fmt.Sprintf("  }\n")
	code += fmt.Sprintf("  return &value, nil\n")
	code += fmt.Sprintf("}\n")

	return code

	// -- Original code (this is what it should be)
	// func UserFromXML(xmldata string) (*User, error) {
	// 	var user User
	// 	err := xml.Unmarshal([]byte(xmldata), &user)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	// 	return &user, nil
	// }

}

func (generator *CodeGenerator) generateFromJSONCode(define *common.XMLDefine) string {
	code := ""

	code += fmt.Sprintf("// %sFromJSON converts a JSON representation to the data type\n", define.Name)
	code += fmt.Sprintf("func %sFromJSON(jsondata string) (*%s, error) {\n", define.Name, define.Name)
	code += fmt.Sprintf("  var value %s\n", define.Name)
	code += fmt.Sprintf("  err := json.Unmarshal([]byte(jsondata), &value)\n")
	code += fmt.Sprintf("  if err != nil {\n")
	code += fmt.Sprintf("	  return nil, err\n")
	code += fmt.Sprintf("  }\n")
	code += fmt.Sprintf("  return &value, nil\n")
	code += fmt.Sprintf("}\n")
	return code

	// -- original code
	// func UserFromJSON(jsondata string) (*User, error) {
	// 	var user User
	// 	err := json.Unmarshal([]byte(jsondata), &user)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	// 	return &user, nil
	// }
}
